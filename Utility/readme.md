# mutex
## 信号量
信号量通常通过两个原子操作来使用：

P操作（Wait操作）：当一个进程想要访问一个受保护的资源时，它首先会对信号量执行P操作。如果信号量的值大于零，那么该操作会使信号量的值减一，并允许进程继续执行；如果信号量的值为零，则表明没有可用资源，此时进程会被阻塞，直到信号量的值变为正数。
V操作（Signal操作）：当一个进程完成对资源的访问时，它会对信号量执行V操作。V操作会增加信号量的值，并且如果信号量的值为负数（意味着有等待的进程），则会选择一个处于等待状态的进程使其变为就绪状态，以便它能继续执行。
信号量可以用来解决多种并发问题，比如生产者消费者问题、读者写者问题等。信号量分为二进制信号量（通常用于实现互斥锁）、计数信号量（可以表示多个资源的可用性）和通用信号量（可以用来实现更复杂的同步需求）。

## 局部锁模板
利用raii的方式实现，实现一个局部锁模板，可以减少代码量，简化代码逻辑。
~~~cpp
    template <class T>
    struct ScopedLockImpl
    {
    public:
        /// @brief 构造函数
        /// @param mutex mutex
        ScopedLockImpl(T &mutex)
            : m_mutex(mutex)
        {
            m_mutex.lock();
            b_locked = true;
        }
        ScopedLockImpl(const ScopedLockImpl &) = delete;            // 禁止复制构造
        ScopedLockImpl &operator=(const ScopedLockImpl &) = delete; // 禁止赋值
        ~ScopedLockImpl()
        {
            unlock();
        }
        void lock()
        {
            if (b_locked)
            {
                return;
            }
            m_mutex.lock();
            b_locked = true;
        }
        void unlock()
        {
            if (!b_locked)
            {
                return;
            }
            m_mutex.unlock();
            b_locked = false;
        }

    private:
        T &m_mutex;
        bool b_locked;
    };
~~~

## 自旋锁Spinlock
spinlock（自旋锁）是一种常用的同步机制，主要用于多处理器环境下的并发控制。与传统的锁机制（如互斥锁）不同，自旋锁在等待锁时不会放弃CPU时间片，而是持续“自旋”（即循环检查锁的状态），直到锁可用为止。

**自旋锁的特点**

**不放弃CPU时间片**：
当一个线程尝试获取已经被其他线程持有的自旋锁时，它不会放弃CPU时间片，而是不断循环检查锁的状态。
这种方式适用于锁持有时间非常短的情况，因为频繁的上下文切换可能会比自旋消耗更多的资源。

**适用于短锁持有时间**：
自旋锁最适合用于锁持有时间非常短的场景，因为长时间自旋会导致浪费大量的CPU资源。

**无上下文切换**：
自旋锁避免了上下文切换带来的开销，因此在某些情况下性能更好。

**原子操作**：
自旋锁通常通过原子操作（如compare-and-swap）来实现。

**自旋锁的应用场景**

多处理器环境：在多处理器环境下，自旋锁可以有效减少上下文切换的开销。

短时间锁定：适用于需要快速锁定和解锁的场景，如缓存操作、队列操作等。

高并发环境：在高并发环境中，自旋锁可以减少线程调度的开销。

## 互斥量
互斥量（Mutex，Mutual Exclusion Object）是一种同步机制，用于在多线程或多进程环境中保护对共享资源的访问，确保任何时刻只有一个线程或进程能够访问临界区（Critical Section）。互斥量的基本原理是通过锁定机制来实现对共享资源的独占访问。

互斥量的特性

独占访问：互斥量确保任何时候只有一个线程能够访问临界区，从而避免了多个线程同时修改共享资源导致的数据不一致问题。

阻塞等待：当一个线程试图获取一个已经被其他线程持有的互斥量时，该线程会被阻塞，直到互斥量被释放。

所有权：互斥量具有所有权的概念，即只有拥有互斥量的线程才能释放互斥量。

递归锁：一些互斥量支持递归锁定，即一个线程可以多次获取同一个互斥量而不会导致死锁。

优先级翻转：互斥量可以采用优先级继承等机制来防止优先级翻转现象，即低优先级线程持有互斥量时，高优先级线程无法获取互斥量而被阻塞。

## 互斥量于自旋锁的区别

阻塞 vs 非阻塞：
互斥量：当线程无法获取互斥量时，该线程会被阻塞，直到互斥量可用。
自旋锁：当线程无法获取自旋锁时，它会持续循环检查锁的状态，直到锁可用。
上下文切换：

互斥量：由于线程在等待互斥量时会被阻塞，因此会发生上下文切换。
自旋锁：自旋锁不会导致上下文切换，因为线程会一直占用CPU资源。
适用场景：

互斥量：适用于锁持有时间较长的场景，因为线程阻塞并不会消耗过多的CPU资源。
自旋锁：适用于锁持有时间非常短的场景，以避免上下文切换的开销。

## CASLock

CAS锁（Compare and Swap Lock），通常指的是利用CAS（Compare and Swap）操作来实现的一种乐观锁机制。CAS操作是一种原子操作，它允许线程在不使用传统互斥锁的情况下，检查并更新内存中的值。CAS锁通常用于实现无锁并发算法，它通过不断尝试更新内存中的值来获取锁，而不是通过阻塞线程来等待锁的释放。